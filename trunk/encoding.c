/* 
Copyright 2008, David Allan

This file is part of raopd.

raopd is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your
option) any later version.

raopd is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with raopd.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <nettle/base64.h>

#include <nssb64.h>
#include <secitem.h>

#include "lt.h"
#include "utility.h"
#include "encoding.h"
#include "syscalls.h"

#define DEFAULT_FACILITY LT_ENCODING

utility_retcode_t raopd_base64_encode_nettle(char *dst,
					     size_t dstlen,
					     uint8_t *src,
					     size_t srclen,
					     size_t *encoded_length)
{
	utility_retcode_t ret = UTILITY_SUCCESS;

	FUNC_ENTER;

	*encoded_length = BASE64_ENCODE_RAW_LENGTH(srclen);

	DEBG("source length: %d encoded length: %d destination length: %d\n",
	     (int)srclen, (int)*encoded_length, (int)dstlen);

	if (*encoded_length > dstlen) {
		WARN("Destination string was too short (%d bytes) for "
		     "encoded string (%d bytes)\n",
		     dstlen,
		     *encoded_length);

		ret = UTILITY_FAILURE;
	} else {
		base64_encode_raw((uint8_t *)dst, (unsigned)srclen, (const uint8_t *)src);
	}

	FUNC_RETURN;
	return ret;
}


utility_retcode_t raopd_base64_decode_nettle(uint8_t *dst,
					     size_t dstlen,
					     char *src,
					     size_t srclen,
					     size_t *decoded_length)
{
	utility_retcode_t ret = UTILITY_SUCCESS;
	struct base64_decode_ctx ctx;

	FUNC_ENTER;

	*decoded_length = BASE64_DECODE_LENGTH(srclen);

	DEBG("source length: %d decoded length: %d destination length: %d\n",
	     (int)srclen, (int)*decoded_length, (int)dstlen);

	if (*decoded_length > dstlen) {
		WARN("Destination string was too short when base64 decoding\n");
		ret = UTILITY_FAILURE;
		goto out;
	}

	base64_decode_init(&ctx);
	if (1 != base64_decode_update(&ctx,
				      decoded_length,
				      dst,
				      srclen,
				      (const uint8_t *)src)) {
		ERRR("base64 decode of \"%s\" failed\n", src);
		ret = UTILITY_FAILURE;
		goto out;
	}

	INFO("Decoded %d bytes\n", (int)*decoded_length);

out:
	FUNC_RETURN;
	return ret;
}


/* The following function is necessary because the AirPort barfs on
 * the properly columnated base64 encoding generated by NSS. */
static void remove_base64_columnation(char *s, size_t *len)
{
	size_t i, j = 0;

	FUNC_ENTER;

	for (i = 0 ; i < *len ; i++) {
		if (s[i] != '\r' && s[i] != '\n') {
			s[j] = s[i];
			j++;
		}
	}

	/* Reset the encoded length */
	*len = j;

	FUNC_RETURN;
	return;
}


utility_retcode_t raopd_base64_encode_nss(char *dst,
					  size_t dstlen,
					  uint8_t *src,
					  size_t srclen,
					  size_t *encoded_length)
{
	utility_retcode_t ret = UTILITY_SUCCESS;
	SECItem data_to_encode;

	FUNC_ENTER;

	/* SECItem.type appears to be ignored by the encoder */
	data_to_encode.data = src;
	data_to_encode.len = srclen;

	syscalls_memset(dst, 0, dstlen);

	if (NULL == NSSBase64_EncodeItem(NULL, dst, dstlen, &data_to_encode)) {
		ERRR("Failed to base64 encode buffer of length %d\n", srclen);
		goto out;
	}

	*encoded_length = syscalls_strlen(dst);

	DEBG("source length: %d encoded length: %d destination length: %d\n",
	     (int)srclen, (int)*encoded_length, (int)dstlen);

	remove_base64_columnation(dst, encoded_length);

out:
	FUNC_RETURN;
	return ret;
}


utility_retcode_t raopd_base64_decode_nss(uint8_t *dst,
					  size_t dstlen,
					  const char *src,
					  const size_t srclen,
					  size_t *decoded_length)
{
	utility_retcode_t ret = UTILITY_SUCCESS;
	SECItem *nss_base64_result;

	FUNC_ENTER;

	nss_base64_result = NSSBase64_DecodeBuffer(NULL, NULL, src, srclen);
	*decoded_length = nss_base64_result->len;

	DEBG("source length: %d decoded length: %d destination length: %d\n",
	     (int)srclen, (int)*decoded_length, (int)dstlen);

	if (*decoded_length > dstlen) {
		WARN("Destination string was too short when base64 decoding\n");
		ret = UTILITY_FAILURE;
		goto out;
	}

	syscalls_memcpy(dst, nss_base64_result->data, *decoded_length);

	INFO("Decoded %d bytes\n", (int)*decoded_length);

out:
	SECITEM_FreeItem(nss_base64_result, PR_TRUE);
	FUNC_RETURN;
	return ret;
}


void remove_base64_padding(char *encoded_string)
{
	char *begin_padding;

	FUNC_ENTER;

	begin_padding = syscalls_strchr(encoded_string, '=');

	if (NULL != begin_padding) {
		DEBG("Found padding\n");
		*begin_padding = '\0';
	}

	return;
}
